"""Project Service for managing project lifecycle.

This module provides functionality for creating, updating, and deleting projects,
coordinating operations across Graph Service, Vector Service, and Cache Service.
"""

import logging
from typing import Dict, List, Tuple, Optional

from ..models.base import CodeEntity, CodeRelationship
from .graph_service import GraphService
from .vector_service import VectorService
from .cache_service import CacheService

logger = logging.getLogger(__name__)


class ProjectService:
    """Service for managing project lifecycle operations."""
    
    def __init__(
        self,
        graph_service: Optional[GraphService] = None,
        vector_service: Optional[VectorService] = None,
        cache_service: Optional[CacheService] = None
    ):
        """Initialize the project service.
        
        Args:
            graph_service: Graph service for structural data
            vector_service: Vector service for embeddings
            cache_service: Cache service for query results
        """
        self.graph_service = graph_service or GraphService()
        self.vector_service = vector_service or VectorService()
        self.cache_service = cache_service or CacheService()
    
    async def delete_project(
        self,
        project_id: str
    ) -> Dict[str, any]:
        """Delete all data for a project across all services.
        
        Deletes:
        - All entities and relationships from Neo4j
        - All embeddings from Chroma
        - All cache entries from Redis
        
        Args:
            project_id: Project identifier
            
        Returns:
            Dictionary with deletion statistics from all services
            
        Validates: Requirements 12.4
        """
        logger.info(f"Deleting project {project_id} from all services")
        
        stats = {
            'project_id': project_id,
            'graph': {},
            'vector': {},
            'cache': {}
        }
        
        try:
            # Delete from Neo4j
            logger.info(f"Deleting project {project_id} from Neo4j")
            graph_stats = await self.graph_service.delete_project(project_id)
            stats['graph'] = graph_stats
            
            # Delete from Chroma
            logger.info(f"Deleting project {project_id} embeddings from Chroma")
            embeddings_deleted = self.vector_service.delete_project_embeddings(project_id)
            stats['vector'] = {'embeddings_deleted': embeddings_deleted}
            
            # Invalidate cache
            logger.info(f"Invalidating cache for project {project_id}")
            cache_deleted = self.cache_service.invalidate_project(project_id)
            stats['cache'] = {'entries_deleted': cache_deleted}
            
            logger.info(f"Project {project_id} deleted successfully: {stats}")
            return stats
            
        except Exception as e:
            logger.error(f"Failed to delete project {project_id}: {e}")
            raise
    
    async def update_project(
        self,
        project_id: str,
        changed_files: List[Tuple[str, List[CodeEntity], List[CodeRelationship]]],
        deleted_files: List[str]
    ) -> Dict[str, any]:
        """Incrementally update project with changed and deleted files.
        
        Updates:
        - Entities and relationships in Neo4j
        - Embeddings in Chroma (regenerates for changed entities)
        - Invalidates cache for affected queries
        
        Args:
            project_id: Project identifier
            changed_files: List of (file_path, entities, relationships) for changed files
            deleted_files: List of file paths that were deleted
            
        Returns:
            Dictionary with update statistics from all services
            
        Validates: Requirements 12.3
        """
        logger.info(f"Updating project {project_id}")
        
        stats = {
            'project_id': project_id,
            'graph': {},
            'vector': {},
            'cache': {}
        }
        
        try:
            # Update Neo4j
            logger.info(f"Updating project {project_id} in Neo4j")
            graph_stats = await self.graph_service.update_project(
                project_id,
                changed_files,
                deleted_files
            )
            stats['graph'] = graph_stats
            
            # Delete embeddings for changed/deleted files
            # (New embeddings will be generated by the upload pipeline)
            all_affected_files = deleted_files + [f[0] for f in changed_files]
            embeddings_deleted = 0
            
            for file_path in all_affected_files:
                # Delete embeddings for entities in this file
                # This is a simplified approach; in production, you'd want to
                # track entity IDs more precisely
                logger.debug(f"Deleting embeddings for file {file_path}")
                # Note: Vector service doesn't have a delete by file_path method yet
                # This would need to be implemented for full functionality
            
            stats['vector'] = {'embeddings_deleted': embeddings_deleted}
            
            # Invalidate cache for this project
            logger.info(f"Invalidating cache for project {project_id}")
            cache_deleted = self.cache_service.invalidate_project(project_id)
            stats['cache'] = {'entries_deleted': cache_deleted}
            
            logger.info(f"Project {project_id} updated successfully: {stats}")
            return stats
            
        except Exception as e:
            logger.error(f"Failed to update project {project_id}: {e}")
            raise


def get_project_service() -> ProjectService:
    """Get a project service instance.
    
    Returns:
        ProjectService instance
    """
    return ProjectService()
