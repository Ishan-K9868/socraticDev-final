# Code Visualizer Deep Audit Report

## 1. Findings

**1. Fallback Logic Cannot Handle Offline Endpoints**
- **Severity**: High
- **File**: `frontend/src/services/graphrag-api.ts` (Line ~354)
- **Why it is risky**: The fallback loop (`for (const base of orderedCandidates)`) catches errors and uses `is404 = msg.includes('404')` to decide whether to try the next endpoint. If the primary base URL is completely offline (e.g., connection refused), Axios throws a Network Error without a 404 status. The code explicitly does `if (is404) { continue; } throw error;`, thereby immediately throwing and aborting the fallback sequence.
- **Real-world impact**: If the user switches from port 8000 to 8002 and the old port is dead, the frontend throws a "Network Error" immediately instead of probing the other candidates, completely defeating the purpose of the fallback logic. 
- **Concrete fix**: In the loop's catch block, allow fallback for network errors as well:
  `const shouldFallback = is404 || !error.response || msg.includes('Network Error');`
  `if (shouldFallback) continue;`

**2. Trace Errors Masked on Empty Execution**
- **Severity**: Medium
- **File**: `frontend/src/features/visualizer/useCodeAnalysis.ts` (Line ~176)
- **Why it is wrong**: When tracing execution, if the backend hits an early timeout or runtime error before generating steps (e.g., timeout compiling), the backend returns `{"steps": [], "error": "Execution timed out..."}`. The frontend `sanitizeTrace` retains this `.error`, but the caller does `if (!trace.steps.length) { throw new Error('Analyzer returned empty execution trace'); }`.
- **Real-world impact**: A timeout or immediate script failure completely drops the informative backend error message and displays the useless "empty execution trace" message to the user instead.
- **Concrete fix**: Surface the actual backend error if present:
  `if (!trace.steps.length) { throw new Error(trace.error || 'Analyzer returned empty execution trace'); }`

**3. Orphaned Port 8000 Cleanup Function**
- **Severity**: Low
- **File**: `start.bat` (Line ~584)
- **Why it is wrong**: The script defines a `:stop_conflicting_port_8000` subroutine designed to clean up older instances of the app on the previous port. However, it is never called anywhere in the startup sequence (only the `API_PORT` 8002 cleaner is called).
- **Real-world impact**: Legacy Python background processes from before the port migration may continue spinning indefinitely, wasting RAM and potentially blocking DB resources.
- **Concrete fix**: Add `call :stop_conflicting_port_8000` inside `:start_backend_processes` right before `call :clear_listener_on_api_port`.

**4. Subprocess Sandboxing Ineffective on Windows**
- **Severity**: Low
- **File**: `backend/src/services/visualizer_ai_service.py` (Line ~296)
- **Why it is risky**: The deterministic sandbox script tries to use the `resource` module to set strict CPU/memory limits. But `resource` is Unix-only. On Windows, it silently hits `except Exception: pass`, applying zero memory or OS-level CPU constraints. 
- **Real-world impact**: Since `socraticDev` explicitly caters to Windows (e.g. `start.bat`), a runaway memory allocation (e.g., `x = "a" * 10**10`) in the user code will completely bypass the `timeout_ms` polling loop and crash the host Celery/API worker with an OOM.
- **Concrete fix**: Document this limitation for local Windows use, or implement Windows-native limits using `psutil` or by wrapping the trace in a Docker container in production.

## 2. Correctness verdict
**Verdict: Implementation is directionally correct**
**Rationale**: The architectural choices are solid. Using AST visitors for graph generation and `sys.settrace` for tracing are precise, deterministic approaches that outclass naive regexes. The API contracts match perfectly, React hooks are properly sequentialized using monotonic `requestSeq` IDs, and data is aggressively sanitized before rendering. The identified issues are solely around heuristic edge cases (fallback behavior on socket errors, specific error message rendering), not fundamental architectural flaws.

## 3. Minimal patch plan
1. **Fix Fallback (High)**: Update `graphrag-api.ts` so `shouldFallback` accounts for Network Errors / lack of response object, not just 404s.
2. **Fix Error Visibility (Medium)**: In `useCodeAnalysis.ts`, change the empty-steps throw to `throw new Error(trace.error || 'Analyzer returned...');`.
3. **Fix Cleanup (Low)**: Add `call :stop_conflicting_port_8000` in `start.bat` under `:start_backend_processes`.

## 4. Optional quick wins
- **UI State**: In `ExecutionAnimator.tsx`, if the trace finishes with an error (e.g. `trace.error` is set), consider highlighting the error in red at the bottom of the output window to explicitly indicate a runtime failure rather than a successful termination.
- **Sandbox Globals**: `safe_builtins` in the backend leaves out `dir`, `vars`, and `locals()` which might be useful for users wanting to inspect state explicitly, though the auto-sampler handles most of it.
